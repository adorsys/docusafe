Verschlüsselung:
================

Annahme: Ein Benutzer speichert immer nur Daten für sich selbst. 

Der Benutzer geht zum IDP-Server. 
_________________________________
Input: 		Username, Password
Output:		JWT enthält (UserID, SpecialPasswordHash)
Process:	
			Definition: Der SpecialPasswordHash ist der symmetrische Schlüssel, mit 
			dem der private Schlüssel im ResourceServer verschlüsselt ist.
			
			Nach der Authentifizierung und der Autorisierung des Benutzers wird der 
			SpecialPasswordHash erstellt. Dieser darf nicht identisch sein zum 
			PasswordHash, der im System gespeichert ist, da ansonsten eine direkte 
			Beziehung von der UserID zum PrivateKey bestünde. Der SpecialPasswordHash
			könnte z.B. der Hash einer fest definierte Permutation des Passwortes sein.
			
			Der SpecialPasswordHash wird nur bei der Entschlüsselung benötigt. Für die
			Verschlüsselung ist er nicht von Belang
			
Der Benutzer geht zum ResourceServer.
_____________________________________
Input: 		Document, JWT enthält (UserID, (SpecialPasswordHash))
Output: 	DocumentID
Process:	Es wird ein neuer symmetrischer Schlüssel erzeugt. Dieser wird nicht 
			persistiert. Dieser Schlüssel wird benutzt, um das Document symmetrisch zu 
			verschlüsseln. Das verschlüsselte Document erhält eine DocumentID. Dieses
			Tupel (DocumentID -> encryptedDocument) wird persistiert. Anhand der UserID
			wird nun der PublicKey des Benutzers gefunden, d.h. es gibt ein persistentes
			Tupel (UserID -> PublicKey). Nun wird der zuvor erzeugte symmetrische Schlüssel 
			des encryptedDocuments mit dem PublicKey des Benutzers verschlüsselt. Diesen
			encryptedKey nennt man DocumentGuard. Persistiert wird das Tupel 
			(UserID, DocumentID -> DocumentGuard). Das Tupel (DocumentID -> DocumentGuard) 
			könnte unter später genannten Voraussetzungen ausreichen.
			Die DocumentID wird zurückgegeben.
	 
Entschlüsselung:
================

Der Benutzer geht zum IDP-Server. 
_________________________________
Input: 		Username, Password
Output:		JWT enthält (UserID, SpecialPasswordHash)
Process:	Siehe oben
	 
Der Benutzer geht zum ResourceServer.
_____________________________________
Input: 		Document, JWT enthält (UserID, SpecialPasswordHash)
Output: 	DocumentID
Process:	Anhand des Tupels (UserID -> PrivateKeyGuard) wird der PrivateKeyGuard
			des Benutzers ermittelt. Anhand des Tupels (UserID, DocumentID -> DocumentGuard) 
			wird der DocumentGuard ermittelt. Mit dem SpecialPasswordHash wird der
			PrivateKeyGuard entschlüsselt. Man erhält den PrivateKey des Benutzers.
			Mit dem PrivateKey des Benutzers wird nun der DocumentGuard entschlüsselt.
			Man enthält den symmetrischen Schlüssel des Documents. Anhand des Tupels
			(UserID, DocumentID -> encryptedDocument) wird das encryptedDocument
			ermittelt. Dies wird nun mit dem symmetrischen Schlüssel decrypted. 
			
Persistente Relationen:
=======================
IDP Server:
	(Username -> UserID, PasswordHash)
ResourceServer:
	(UserID -> PublicKey)
	(UserID, DocumentID -> DocumentGuard)
	(DocumentID -> encryptedDocument)
	(UserID -> PrivateKeyGuard)
	
	
Verstärkte Sicherheit
======================
(1)
Es ist nicht gut, den SpecialPasswordHash direkt aus dem IDP-Server zurück an den 
Benutzer zu geben (im JWT). Denn einmal abgefangen, liefert dieser immer den privateKey
des Benutzers und damit die Möglichkeit, seine Document zu entschlüsseln. Daher sollte
immer mit dem Sessionbegin ein neues Tupel im ResourceServer erzeugt werden, dessen
Laufzeit sehr begrenzt ist. Modifizierter Ablauf:

Der Benutzer geht zum IDP-Server. 
_________________________________
Input: 		Username, Password
Output:		JWT enthält (UserID, TemporarySpecialPasswordHash)
Process:	
			Definition: Der TemporarySpecialPasswordHash ist der symmetrische Schlüssel, 
			mit dem der private Schlüssel im ResourceServer verschlüsselt ist.
			
			Nach der Authentifizierung und der Autorisierung des Benutzers wird der 
			SpecialPasswordHash erstellt. Das Tupel (UserID, SpecialPasswordHash) 
			wird an den ResourceServer geschickt. Dort wird der PrivateKeyGuard mit dem
			SpecialPasswordHash entsperrt. Der PrivateKey wird nun mit einem neuen,
			im ResourceServer erzeugtem TemporarySpecialPasswordHash verschlüsselt. Dieses
			Tupel ist sehr volatile und nur für die Session zu benutzen. Daher muss es ggf.
			nicht persistiert werden, sondern könnte im Speicher gehalten werden. Der
			TemporarySpecialPasswordHash geht zurück zum IDP-Server und fliesst dort in 
			das JTW ein. Bei der späteren Entschlüsselung eines Documents wird der 
			TemporarySpecialPasswordHash benutzt, um den volatilen PrivateKeyGuard zu
			entschlüsseln.
			
(2)
Sollte der Benutzer sein Kennwort vergessen, kann der SpecialPasswordHash nicht mehr
erzeugt werden. Damit ist der PrivateKey des Benutzers verloren. Die für ihn verschlüsselten
Documente können nicht mehr entschlüsselt werden.
Hier kann auf unterschiedliche Art Abhilfe geschaffen werden:
(2a)
Ein Document wird immer mit einem zweiten SecurityGuard gesichert. Dies ist quasi der
SystemAdmin. Dann wäre aber die Schwachstelle, dass der SystemAdmin immer alle Documente
entschlüsseln könnte.
(2b)
Der PrivateKey des Benutzers erhält neben seinem PrivateKeyGuard noch 
n weitere PrivateKeyGuards, die jeweils immer nur einen Teil des Schlüssels enthalten, so
dass n-1 SpecialPasswordHashes reichen würden, um n-1 PrivateKeyGuards zu öffnen und aus 
den n-1 PrivateKey-Fragmenten den PrivateKey wieder herzustellen.

Die Schwachstellen der Methoden 2a und 2b sind allerdings identisch.

Im Fall der Lösung 2b könnte das Tupel im ResourceServer von 
(UserID, DocumentID -> DocumentGuard) auf (DocumentID -> DocumentGuard) reduziert
werden. 
